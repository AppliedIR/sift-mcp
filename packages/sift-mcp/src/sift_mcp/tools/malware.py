"""Malware analysis tools â€” YARA, strings."""

from __future__ import annotations

from sift_mcp.audit import AuditWriter
from sift_mcp.catalog import get_tool_def
from sift_mcp.environment import find_binary
from sift_mcp.exceptions import ToolNotFoundError
from sift_mcp.executor import execute
from sift_mcp.response import build_response
from sift_mcp.security import sanitize_extra_args, validate_input_path


def register_malware_tools(server, audit: AuditWriter):

    @server.tool()
    def run_yara(rules_file: str, target: str, extra_args: list[str] | None = None) -> dict:
        """Run YARA rules against a target file or directory."""
        validate_input_path(rules_file)
        validate_input_path(target)
        td = get_tool_def("yara")
        if not td:
            raise ValueError("yara not in catalog")
        binary_path = find_binary(td.binary)
        if not binary_path:
            raise ToolNotFoundError("yara not found.")
        extra_args = sanitize_extra_args(extra_args or [], "run_yara")
        cmd = [binary_path] + extra_args + [rules_file, target]
        evidence_id = audit._next_evidence_id()
        exec_result = execute(cmd, timeout=600)
        response = build_response(
            tool_name="run_yara", success=exec_result["exit_code"] == 0,
            data=exec_result.get("stdout", ""), evidence_id=evidence_id,
            output_format="text", elapsed_seconds=exec_result["elapsed_seconds"],
            exit_code=exec_result["exit_code"], command=cmd, fk_tool_name="YARA",
        )
        audit.log(tool="run_yara", params={"rules_file": rules_file, "target": target},
                   result_summary={"exit_code": exec_result["exit_code"]}, evidence_id=evidence_id)
        return response

    @server.tool()
    def run_strings(target_file: str, min_length: int = 4, encoding: str = "s", extra_args: list[str] | None = None) -> dict:
        """Extract strings from a file. encoding: s=ASCII, l=little-endian 16-bit, b=big-endian."""
        validate_input_path(target_file)
        td = get_tool_def("strings")
        if not td:
            raise ValueError("strings not in catalog")
        binary_path = find_binary(td.binary)
        if not binary_path:
            raise ToolNotFoundError("strings not found.")
        extra_args = sanitize_extra_args(extra_args or [], "run_strings")
        cmd = [binary_path, f"-n{min_length}", f"-e{encoding}"] + extra_args + [target_file]
        evidence_id = audit._next_evidence_id()
        exec_result = execute(cmd, timeout=300)
        response = build_response(
            tool_name="run_strings", success=exec_result["exit_code"] == 0,
            data=exec_result.get("stdout", ""), evidence_id=evidence_id,
            output_format="text", elapsed_seconds=exec_result["elapsed_seconds"],
            exit_code=exec_result["exit_code"], command=cmd, fk_tool_name="strings",
        )
        audit.log(tool="run_strings", params={"target_file": target_file},
                   result_summary={"exit_code": exec_result["exit_code"]}, evidence_id=evidence_id)
        return response
